#include <iostream>

#include <AMReX.H>
#include <AMReX_ParmParse.H>
#include <AMReX_Print.H>

#include "sledgehamr_init.h"
#include "projects.h"

namespace sledgehamr {

SledgehamrInit::SledgehamrInit() {
    DetermineProjectName();
    FinishAMReXSetup();
}

/*
Sledgehamr* SledgehamrInit::CreateInstance() {
    // Call macro generated by 'make'. Will create and return new instance of
    // derived project class corresponding to the requested project name. Will
    // do nothing if no matching project class found. Implicit cast to base upon
    // return.
    SLEDGEHAMR_PROJECT(project_name);
    amrex::Print() << "Project not found!" << std::endl;
    return NULL;
}
*/
void SledgehamrInit::DetermineProjectName() {
    amrex::ParmParse pp("project");
    pp.get("name",project_name);
}

void SledgehamrInit::FinishAMReXSetup() {
    // Determine requested grid size. Divide by two if a shadow level is
    // requested and set `amr.n_cell` accordingly for amrex::AmrCore.
    int grid_size = 0;
    bool shadow_hierarchy = false;

    amrex::ParmParse pp_amr("amr");
    pp_amr.get("coarse_level_grid_size", grid_size);
    pp_amr.get("shadow_hierarchy", shadow_hierarchy);

    if (shadow_hierarchy)
        grid_size /= 2;

    std::vector<int> grid_vect(3,grid_size);
    pp_amr.addarr("n_cell", grid_vect);

    // Determine maximum number of levels.
    int max_refinement_levels = 0;
    pp_amr.get("max_refinement_levels", max_refinement_levels);

    int max_level = max_refinement_levels + shadow_hierarchy;
    pp_amr.add("max_level", max_level);

    // Set box dimensions.
    amrex::ParmParse pp_sim("sim");
    double L;
    pp_sim.get("L", L);

    std::vector<double> prob_lo(3,0);
    std::vector<double> prob_hi(3,L);
    std::vector<int> periodic(3,1);

    amrex::ParmParse pp_geo("geometry");
    pp_geo.addarr("prob_lo", prob_lo);
    pp_geo.addarr("prob_hi", prob_hi);
    pp_geo.addarr("is_periodic", periodic);

    // Set Integrator type.
    amrex::ParmParse pp_inte("integration");
    int inte_type;
    pp_inte.get("type", inte_type);

    if (inte_type >= 0 && inte_type <= 4) {
        pp_inte.add("type", 1);
        pp_inte.add("rk.type", inte_type);
    }
}

}; // namespace sledgehamr
