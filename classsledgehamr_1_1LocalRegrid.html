<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sledgehamr: sledgehamr::LocalRegrid Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sledgehamr
   </div>
   <div id="projectbrief">Scalar Field Dynamics being solved with Adaptive Mesh Refinement</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesledgehamr.html">sledgehamr</a></li><li class="navelem"><a class="el" href="classsledgehamr_1_1LocalRegrid.html">LocalRegrid</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classsledgehamr_1_1LocalRegrid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sledgehamr::LocalRegrid Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class to perform a local regrid (if possible).  
 <a href="classsledgehamr_1_1LocalRegrid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="local__regrid_8h_source.html">local_regrid.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a48a0392601adc7046203719af5feb824"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a48a0392601adc7046203719af5feb824">LocalRegrid</a> (<a class="el" href="classsledgehamr_1_1Sledgehamr.html">Sledgehamr</a> *owner)</td></tr>
<tr class="memdesc:a48a0392601adc7046203719af5feb824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initalize all needed structures.  <a href="classsledgehamr_1_1LocalRegrid.html#a48a0392601adc7046203719af5feb824">More...</a><br /></td></tr>
<tr class="separator:a48a0392601adc7046203719af5feb824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4458da4a915248888078544b767c6b24"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a4458da4a915248888078544b767c6b24">AttemptRegrid</a> (const int lev)</td></tr>
<tr class="memdesc:a4458da4a915248888078544b767c6b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a local regrid on level lev after checking various criteria.  <a href="classsledgehamr_1_1LocalRegrid.html#a4458da4a915248888078544b767c6b24">More...</a><br /></td></tr>
<tr class="separator:a4458da4a915248888078544b767c6b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8209f8ed254d084ef0c85d17334a84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#ad8209f8ed254d084ef0c85d17334a84b">DidGlobalRegrid</a> (const int lev)</td></tr>
<tr class="memdesc:ad8209f8ed254d084ef0c85d17334a84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">To be called if a global regrid on level lev has been performed. Needed in case this <a class="el" href="classsledgehamr_1_1LocalRegrid.html" title="Class to perform a local regrid (if possible).">LocalRegrid</a> module invoked the global regrid such that we can reset the relevant flags.  <a href="classsledgehamr_1_1LocalRegrid.html#ad8209f8ed254d084ef0c85d17334a84b">More...</a><br /></td></tr>
<tr class="separator:ad8209f8ed254d084ef0c85d17334a84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8f2a065d1f69ad66d46eef5f01d910"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#aca8f2a065d1f69ad66d46eef5f01d910">InitializeLayout</a> (const int max_lev)</td></tr>
<tr class="memdesc:aca8f2a065d1f69ad66d46eef5f01d910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates all layout structures needed for the local regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#aca8f2a065d1f69ad66d46eef5f01d910">More...</a><br /></td></tr>
<tr class="separator:aca8f2a065d1f69ad66d46eef5f01d910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d361cc8d3d5cdf88a3b2af70b98235"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#ad1d361cc8d3d5cdf88a3b2af70b98235">ClearLayout</a> ()</td></tr>
<tr class="memdesc:ad1d361cc8d3d5cdf88a3b2af70b98235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleans up all layout structures after the local regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#ad1d361cc8d3d5cdf88a3b2af70b98235">More...</a><br /></td></tr>
<tr class="separator:ad1d361cc8d3d5cdf88a3b2af70b98235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54eaba36170ad1032ffa996aa1823ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a54eaba36170ad1032ffa996aa1823ef0">FinalizeLayout</a> (const int lev)</td></tr>
<tr class="memdesc:a54eaba36170ad1032ffa996aa1823ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronizes all layout structures across OpenMP threads and MPI ranks for a particular level.  <a href="classsledgehamr_1_1LocalRegrid.html#a54eaba36170ad1032ffa996aa1823ef0">More...</a><br /></td></tr>
<tr class="separator:a54eaba36170ad1032ffa996aa1823ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf96edb1e54961ac32416d58020bd1d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#acf96edb1e54961ac32416d58020bd1d2">WrapIndices</a> (const int lev)</td></tr>
<tr class="memdesc:acf96edb1e54961ac32416d58020bd1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps box indicies across the periodic boundary conditions.  <a href="classsledgehamr_1_1LocalRegrid.html#acf96edb1e54961ac32416d58020bd1d2">More...</a><br /></td></tr>
<tr class="separator:acf96edb1e54961ac32416d58020bd1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8054c3efb82b28b33e3357bda47f3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#ab8054c3efb82b28b33e3357bda47f3ee">JoinBoxArrays</a> (const int lev, amrex::BoxArray &amp;ba)</td></tr>
<tr class="memdesc:ab8054c3efb82b28b33e3357bda47f3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins BoxArray's from multiple nodes. Simplifies box lists only locally for efficiency.  <a href="classsledgehamr_1_1LocalRegrid.html#ab8054c3efb82b28b33e3357bda47f3ee">More...</a><br /></td></tr>
<tr class="separator:ab8054c3efb82b28b33e3357bda47f3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abc012848cab999afceb48d34ba637f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a7abc012848cab999afceb48d34ba637f">AddBoxes</a> (const int lev, amrex::BoxArray &amp;ba)</td></tr>
<tr class="memdesc:a7abc012848cab999afceb48d34ba637f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly add boxes to a given level and fill it with data.  <a href="classsledgehamr_1_1LocalRegrid.html#a7abc012848cab999afceb48d34ba637f">More...</a><br /></td></tr>
<tr class="separator:a7abc012848cab999afceb48d34ba637f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c39f4e8b15c13b471f68e36a9dc33f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#aa3c39f4e8b15c13b471f68e36a9dc33f">FixNesting</a> (const int lev)</td></tr>
<tr class="memdesc:aa3c39f4e8b15c13b471f68e36a9dc33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will expand lower level locally to ensure the fine level is nested properly within.  <a href="classsledgehamr_1_1LocalRegrid.html#aa3c39f4e8b15c13b471f68e36a9dc33f">More...</a><br /></td></tr>
<tr class="separator:aa3c39f4e8b15c13b471f68e36a9dc33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab0a5321f0b195e2b151783bcde5fa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a7ab0a5321f0b195e2b151783bcde5fa7">AddToLayout</a> (const int lev, const int thread, const int i, const int j, const int k)</td></tr>
<tr class="memdesc:a7ab0a5321f0b195e2b151783bcde5fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a particular box to the layout structure.  <a href="classsledgehamr_1_1LocalRegrid.html#a7ab0a5321f0b195e2b151783bcde5fa7">More...</a><br /></td></tr>
<tr class="separator:a7ab0a5321f0b195e2b151783bcde5fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4e903f8bbe42b29f94666c569e734bee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a4e903f8bbe42b29f94666c569e734bee">do_global_regrid</a></td></tr>
<tr class="memdesc:a4e903f8bbe42b29f94666c569e734bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag that will be checked the <a class="el" href="classsledgehamr_1_1TimeStepper.html" title="Class that takes care of the sub-cycling in time algorithm and schedules regrids when necessary.">TimeStepper</a> module to force a global regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#a4e903f8bbe42b29f94666c569e734bee">More...</a><br /></td></tr>
<tr class="separator:a4e903f8bbe42b29f94666c569e734bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0f98de185f108dae15af7e2997d886"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a8d0f98de185f108dae15af7e2997d886">comm_matrix</a></td></tr>
<tr class="memdesc:a8d0f98de185f108dae15af7e2997d886"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI communication matrix. Look-up table used by the <a class="el" href="classsledgehamr_1_1UniqueLayout.html" title="This class ensures the uniqueness of a grid by reducing the problem to sets of touples....">UniqueLayout</a> class.  <a href="classsledgehamr_1_1LocalRegrid.html#a8d0f98de185f108dae15af7e2997d886">More...</a><br /></td></tr>
<tr class="separator:a8d0f98de185f108dae15af7e2997d886"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a5e77b4e9b1abddac86fca72caf4c6f7b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5e77b4e9b1abddac86fca72caf4c6f7b">VetoResult</a> { <a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5e77b4e9b1abddac86fca72caf4c6f7bab74034a8953a287161c018af9d99208e">DoGlobalRegrid</a> = 0
, <a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5e77b4e9b1abddac86fca72caf4c6f7bae9e7deadf6c3947aa59dad71e17a0877">DoNoRegrid</a> = 1
, <a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5e77b4e9b1abddac86fca72caf4c6f7ba86d437133251dcb12a6ce5cd3db39593">DoLocalRegrid</a> = 2
 }</td></tr>
<tr class="separator:a5e77b4e9b1abddac86fca72caf4c6f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3bfc34e198cf1d9091ae557b508c3b83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a3bfc34e198cf1d9091ae557b508c3b83">Prechecks</a> (const int lev)</td></tr>
<tr class="memdesc:a3bfc34e198cf1d9091ae557b508c3b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks pre-conditions whether we even need to attempt a local regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#a3bfc34e198cf1d9091ae557b508c3b83">More...</a><br /></td></tr>
<tr class="separator:a3bfc34e198cf1d9091ae557b508c3b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2eaafd8b0ef4d31171234e56bbbc62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#abd2eaafd8b0ef4d31171234e56bbbc62">InitializeLocalRegrid</a> ()</td></tr>
<tr class="memdesc:abd2eaafd8b0ef4d31171234e56bbbc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up everything needed prior to a local regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#abd2eaafd8b0ef4d31171234e56bbbc62">More...</a><br /></td></tr>
<tr class="separator:abd2eaafd8b0ef4d31171234e56bbbc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdb62c58cea11f1be4fd4db3d827509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a7fdb62c58cea11f1be4fd4db3d827509">ParseInput</a> ()</td></tr>
<tr class="memdesc:a7fdb62c58cea11f1be4fd4db3d827509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses all input parameters related to a local regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#a7fdb62c58cea11f1be4fd4db3d827509">More...</a><br /></td></tr>
<tr class="separator:a7fdb62c58cea11f1be4fd4db3d827509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa044dbf92775ab6f8ad67ddca9be6765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#aa044dbf92775ab6f8ad67ddca9be6765">CreateCommMatrix</a> ()</td></tr>
<tr class="memdesc:aa044dbf92775ab6f8ad67ddca9be6765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a N x N communication matrix M_{ij} between N MPI ranks. The i-th MPI rank talks to the M_{ij}-th MPI rank during the j-th communication cycle. Each rank talks to each other rank exactly once.  <a href="classsledgehamr_1_1LocalRegrid.html#aa044dbf92775ab6f8ad67ddca9be6765">More...</a><br /></td></tr>
<tr class="separator:aa044dbf92775ab6f8ad67ddca9be6765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdf638db8837580b881637a3b5871d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#acbdf638db8837580b881637a3b5871d4">DoAttemptRegrid</a> (const int lev)</td></tr>
<tr class="memdesc:acbdf638db8837580b881637a3b5871d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a local regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#acbdf638db8837580b881637a3b5871d4">More...</a><br /></td></tr>
<tr class="separator:acbdf638db8837580b881637a3b5871d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa728f1d2fe1519e19006258a6f3dd2af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#aa728f1d2fe1519e19006258a6f3dd2af">DetermineAllBoxArrays</a> (const int lev)</td></tr>
<tr class="memdesc:aa728f1d2fe1519e19006258a6f3dd2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines new layout on all levels based on taggin criteria.  <a href="classsledgehamr_1_1LocalRegrid.html#aa728f1d2fe1519e19006258a6f3dd2af">More...</a><br /></td></tr>
<tr class="separator:aa728f1d2fe1519e19006258a6f3dd2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78dd484cbf81ffacfc4a8901a3248ec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#ab78dd484cbf81ffacfc4a8901a3248ec">DetermineNewBoxArray</a> (const int lev)</td></tr>
<tr class="memdesc:ab78dd484cbf81ffacfc4a8901a3248ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags cells on a level and measure distance to coarse/fine boundary. If the tagged cell is too close we expand our layout structure at that location.  <a href="classsledgehamr_1_1LocalRegrid.html#ab78dd484cbf81ffacfc4a8901a3248ec">More...</a><br /></td></tr>
<tr class="separator:ab78dd484cbf81ffacfc4a8901a3248ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e74dd5fc82512098f9516ab1660221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a34e74dd5fc82512098f9516ab1660221">FixAllNesting</a> ()</td></tr>
<tr class="memdesc:a34e74dd5fc82512098f9516ab1660221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures that all levels are properly nested within the lower levels.  <a href="classsledgehamr_1_1LocalRegrid.html#a34e74dd5fc82512098f9516ab1660221">More...</a><br /></td></tr>
<tr class="separator:a34e74dd5fc82512098f9516ab1660221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5a104f1c94bd81627803b13225c32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5c5a104f1c94bd81627803b13225c32e">JoinAllBoxArrays</a> (std::vector&lt; amrex::BoxArray &gt; &amp;box_arrays)</td></tr>
<tr class="memdesc:a5c5a104f1c94bd81627803b13225c32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines all BoxArray's on each level.  <a href="classsledgehamr_1_1LocalRegrid.html#a5c5a104f1c94bd81627803b13225c32e">More...</a><br /></td></tr>
<tr class="separator:a5c5a104f1c94bd81627803b13225c32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb58fcf06a2c658aec35d9b175440d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#aefb58fcf06a2c658aec35d9b175440d1">AddAllBoxes</a> (std::vector&lt; amrex::BoxArray &gt; &amp;box_arrays)</td></tr>
<tr class="memdesc:aefb58fcf06a2c658aec35d9b175440d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all boxes on all levels to the grid.  <a href="classsledgehamr_1_1LocalRegrid.html#aefb58fcf06a2c658aec35d9b175440d1">More...</a><br /></td></tr>
<tr class="separator:aefb58fcf06a2c658aec35d9b175440d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91da1033161cc643d7e352c845a81b85"><td class="memItemLeft" align="right" valign="top">amrex::BoxArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a91da1033161cc643d7e352c845a81b85">WrapBoxArray</a> (amrex::BoxArray &amp;ba, int N)</td></tr>
<tr class="memdesc:a91da1033161cc643d7e352c845a81b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a box array accross periodic boundary conditions.  <a href="classsledgehamr_1_1LocalRegrid.html#a91da1033161cc643d7e352c845a81b85">More...</a><br /></td></tr>
<tr class="separator:a91da1033161cc643d7e352c845a81b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4dfcab9bf143c7d284387c643c66fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a1e4dfcab9bf143c7d284387c643c66fe">GetBoxCoarseFineBorders</a> (const amrex::Box &amp;tilebox, const amrex::IntVect &amp;c0, const amrex::IntVect &amp;c1, const int lev, boost::multi_array&lt; bool, 3 &gt; &amp;border)</td></tr>
<tr class="memdesc:a1e4dfcab9bf143c7d284387c643c66fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a box has neighbouring coarse/fine boundaries.  <a href="classsledgehamr_1_1LocalRegrid.html#a1e4dfcab9bf143c7d284387c643c66fe">More...</a><br /></td></tr>
<tr class="separator:a1e4dfcab9bf143c7d284387c643c66fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acdc638840f81d22adff7ad9bd1f4cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a8acdc638840f81d22adff7ad9bd1f4cf">TagAndMeasure</a> (const amrex::Dim3 &amp;lo, const amrex::Dim3 &amp;hi, int remaining, const amrex::Array4&lt; char &gt; &amp;tag_arr, const amrex::IntVect &amp;c0, const amrex::IntVect &amp;c1, const int lev, const int ibff, const double bff, boost::multi_array&lt; bool, 3 &gt; &amp;border, std::vector&lt; <a class="el" href="classsledgehamr_1_1Location.html">Location</a> &gt; &amp;closest_locations, const double threshold, const int omp_thread_num)</td></tr>
<tr class="memdesc:a8acdc638840f81d22adff7ad9bd1f4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds tagged cells within a box and measures its distance of any coarse/fine boundary.  <a href="classsledgehamr_1_1LocalRegrid.html#a8acdc638840f81d22adff7ad9bd1f4cf">More...</a><br /></td></tr>
<tr class="separator:a8acdc638840f81d22adff7ad9bd1f4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7904cbeebaf630718c2fd6c358b0ffab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a7904cbeebaf630718c2fd6c358b0ffab">CheckBorders</a> (const amrex::IntVect &amp;ci, const amrex::IntVect &amp;c0, const amrex::IntVect &amp;c1, const int ibff, const double bff, int remaining, const int lev, boost::multi_array&lt; bool, 3 &gt; &amp;border, std::vector&lt; <a class="el" href="classsledgehamr_1_1Location.html">Location</a> &gt; &amp;closest_locations, const double threshold, const int omp_thread_num)</td></tr>
<tr class="memdesc:a7904cbeebaf630718c2fd6c358b0ffab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a location we measure the distance to all adjacent coarse/fine boundaries. We add to our layout structure if the location is too close.  <a href="classsledgehamr_1_1LocalRegrid.html#a7904cbeebaf630718c2fd6c358b0ffab">More...</a><br /></td></tr>
<tr class="separator:a7904cbeebaf630718c2fd6c358b0ffab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0ce70c479608f2786a4706a1e28174"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a3a0ce70c479608f2786a4706a1e28174">CheckThresholds</a> (const int lev, amrex::BoxArray &amp;box_array)</td></tr>
<tr class="memdesc:a3a0ce70c479608f2786a4706a1e28174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all thresholds and determines whether we should continue with the local regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#a3a0ce70c479608f2786a4706a1e28174">More...</a><br /></td></tr>
<tr class="separator:a3a0ce70c479608f2786a4706a1e28174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4c4e0124cce6e52a2d31d422cd1867"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5a4c4e0124cce6e52a2d31d422cd1867">ComputeLatestPossibleRegridTime</a> (const int l, const int lev)</td></tr>
<tr class="memdesc:a5a4c4e0124cce6e52a2d31d422cd1867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the most pessimistiv time by which we should have performed any regrid or otherwise we run risk of having features propagate outside a refined region.  <a href="classsledgehamr_1_1LocalRegrid.html#a5a4c4e0124cce6e52a2d31d422cd1867">More...</a><br /></td></tr>
<tr class="separator:a5a4c4e0124cce6e52a2d31d422cd1867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0308e5b708bddbedfabc7d5462507b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a8f0308e5b708bddbedfabc7d5462507b">CheckForVeto</a> (const int lev, std::vector&lt; amrex::BoxArray &gt; &amp;box_arrays)</td></tr>
<tr class="memdesc:a8f0308e5b708bddbedfabc7d5462507b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indentifies whether any part of the code wants to veto the local regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#a8f0308e5b708bddbedfabc7d5462507b">More...</a><br /></td></tr>
<tr class="separator:a8f0308e5b708bddbedfabc7d5462507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69abb9abd18afb23af2854dab85b325e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5e77b4e9b1abddac86fca72caf4c6f7b">VetoResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a69abb9abd18afb23af2854dab85b325e">DealWithVeto</a> (const int lev)</td></tr>
<tr class="memdesc:a69abb9abd18afb23af2854dab85b325e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the best course of action in case the local regrid was vetoed. This could be either to do nothing, do a global regrid, or or to do a local regrid anyway followed by a global regrid at the next opportunity.  <a href="classsledgehamr_1_1LocalRegrid.html#a69abb9abd18afb23af2854dab85b325e">More...</a><br /></td></tr>
<tr class="separator:a69abb9abd18afb23af2854dab85b325e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3d091ebbe33a613e98ac5e0a6584f7d9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a3d091ebbe33a613e98ac5e0a6584f7d9">volume_threshold_accumulated</a> = 1.1</td></tr>
<tr class="memdesc:a3d091ebbe33a613e98ac5e0a6584f7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strong threshold that decide whether we want to do a local or global regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#a3d091ebbe33a613e98ac5e0a6584f7d9">More...</a><br /></td></tr>
<tr class="separator:a3d091ebbe33a613e98ac5e0a6584f7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e235329d39882b756791f9e94e609d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#ae7e235329d39882b756791f9e94e609d">volume_threshold_single</a> = 1.05</td></tr>
<tr class="memdesc:ae7e235329d39882b756791f9e94e609d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weak threshold that decide whether we want to do a local or global regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#ae7e235329d39882b756791f9e94e609d">More...</a><br /></td></tr>
<tr class="separator:ae7e235329d39882b756791f9e94e609d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e86a8af0dd02440edea03389daeb1d3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5e86a8af0dd02440edea03389daeb1d3">veto_level</a> = -1</td></tr>
<tr class="memdesc:a5e86a8af0dd02440edea03389daeb1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowest level that would rather do a global regrid than a local.  <a href="classsledgehamr_1_1LocalRegrid.html#a5e86a8af0dd02440edea03389daeb1d3">More...</a><br /></td></tr>
<tr class="separator:a5e86a8af0dd02440edea03389daeb1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ed6ede76749d7a30af53b4e996679b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a22ed6ede76749d7a30af53b4e996679b">force_global_regrid_at_restart</a> = 0</td></tr>
<tr class="memdesc:a22ed6ede76749d7a30af53b4e996679b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If flag set to true we will skip the local regrid once.  <a href="classsledgehamr_1_1LocalRegrid.html#a22ed6ede76749d7a30af53b4e996679b">More...</a><br /></td></tr>
<tr class="separator:a22ed6ede76749d7a30af53b4e996679b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713ec6e07916351b8b41ecab3f2e2a17"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a713ec6e07916351b8b41ecab3f2e2a17">max_local_regrids</a> = 10</td></tr>
<tr class="memdesc:a713ec6e07916351b8b41ecab3f2e2a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">How often we are allowed to do a local regrid in a row.  <a href="classsledgehamr_1_1LocalRegrid.html#a713ec6e07916351b8b41ecab3f2e2a17">More...</a><br /></td></tr>
<tr class="separator:a713ec6e07916351b8b41ecab3f2e2a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042da77091f22870797a9d406fa12506"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a042da77091f22870797a9d406fa12506">nregrids</a> = 0</td></tr>
<tr class="memdesc:a042da77091f22870797a9d406fa12506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts number of consecutive local regrids.  <a href="classsledgehamr_1_1LocalRegrid.html#a042da77091f22870797a9d406fa12506">More...</a><br /></td></tr>
<tr class="separator:a042da77091f22870797a9d406fa12506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8403a32f1028bda506f2e2f4ea7e7eef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a8403a32f1028bda506f2e2f4ea7e7eef">n_error_buf</a> = 1</td></tr>
<tr class="memdesc:a8403a32f1028bda506f2e2f4ea7e7eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of error buffer.  <a href="classsledgehamr_1_1LocalRegrid.html#a8403a32f1028bda506f2e2f4ea7e7eef">More...</a><br /></td></tr>
<tr class="separator:a8403a32f1028bda506f2e2f4ea7e7eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13a330b0df260418a96b950fb3446bc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; long long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#aa13a330b0df260418a96b950fb3446bc">last_numPts</a></td></tr>
<tr class="memdesc:aa13a330b0df260418a96b950fb3446bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of cells contained in each level after the last global regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#aa13a330b0df260418a96b950fb3446bc">More...</a><br /></td></tr>
<tr class="separator:aa13a330b0df260418a96b950fb3446bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb324e0d3669efb0a2337b69892ef957"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#abb324e0d3669efb0a2337b69892ef957">no_local_regrid</a></td></tr>
<tr class="memdesc:abb324e0d3669efb0a2337b69892ef957"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we want to skip the local regrid entirely at a given level.  <a href="classsledgehamr_1_1LocalRegrid.html#abb324e0d3669efb0a2337b69892ef957">More...</a><br /></td></tr>
<tr class="separator:abb324e0d3669efb0a2337b69892ef957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c0c64729d05d204f461d223d01bc72"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#ab5c0c64729d05d204f461d223d01bc72">wrapped_index</a></td></tr>
<tr class="memdesc:ab5c0c64729d05d204f461d223d01bc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look-up table of wrapped indices for periodic boundary conditions.  <a href="classsledgehamr_1_1LocalRegrid.html#ab5c0c64729d05d204f461d223d01bc72">More...</a><br /></td></tr>
<tr class="separator:ab5c0c64729d05d204f461d223d01bc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c65ca82aff444f6e0ec107f092d970e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a7c65ca82aff444f6e0ec107f092d970e">latest_possible_regrid_time</a></td></tr>
<tr class="memdesc:a7c65ca82aff444f6e0ec107f092d970e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the time by which we should have done a regrid.  <a href="classsledgehamr_1_1LocalRegrid.html#a7c65ca82aff444f6e0ec107f092d970e">More...</a><br /></td></tr>
<tr class="separator:a7c65ca82aff444f6e0ec107f092d970e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7979ef82194a55c08f939f5cfd33d943"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a7979ef82194a55c08f939f5cfd33d943">min_distance</a></td></tr>
<tr class="memdesc:a7979ef82194a55c08f939f5cfd33d943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum distance of a tagged cell to a coarse/fine boundary for each OpenMP thread.  <a href="classsledgehamr_1_1LocalRegrid.html#a7979ef82194a55c08f939f5cfd33d943">More...</a><br /></td></tr>
<tr class="separator:a7979ef82194a55c08f939f5cfd33d943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b38ea21c94615db481b11a56fadd9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::unique_ptr&lt; <a class="el" href="classsledgehamr_1_1UniqueLayout.html">UniqueLayout</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a48b38ea21c94615db481b11a56fadd9f">layouts</a></td></tr>
<tr class="memdesc:a48b38ea21c94615db481b11a56fadd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of UniqueLayouts for each level and each core.  <a href="classsledgehamr_1_1LocalRegrid.html#a48b38ea21c94615db481b11a56fadd9f">More...</a><br /></td></tr>
<tr class="separator:a48b38ea21c94615db481b11a56fadd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d60672b3f1690a0b299a97b36358648"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsledgehamr_1_1Sledgehamr.html">Sledgehamr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a4d60672b3f1690a0b299a97b36358648">sim</a></td></tr>
<tr class="memdesc:a4d60672b3f1690a0b299a97b36358648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the simulation.  <a href="classsledgehamr_1_1LocalRegrid.html#a4d60672b3f1690a0b299a97b36358648">More...</a><br /></td></tr>
<tr class="separator:a4d60672b3f1690a0b299a97b36358648"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to perform a local regrid (if possible). </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5e77b4e9b1abddac86fca72caf4c6f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e77b4e9b1abddac86fca72caf4c6f7b">&#9670;&nbsp;</a></span>VetoResult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5e77b4e9b1abddac86fca72caf4c6f7b">sledgehamr::LocalRegrid::VetoResult</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e77b4e9b1abddac86fca72caf4c6f7bab74034a8953a287161c018af9d99208e"></a>DoGlobalRegrid&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5e77b4e9b1abddac86fca72caf4c6f7bae9e7deadf6c3947aa59dad71e17a0877"></a>DoNoRegrid&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5e77b4e9b1abddac86fca72caf4c6f7ba86d437133251dcb12a6ce5cd3db39593"></a>DoLocalRegrid&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a48a0392601adc7046203719af5feb824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a0392601adc7046203719af5feb824">&#9670;&nbsp;</a></span>LocalRegrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sledgehamr::LocalRegrid::LocalRegrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsledgehamr_1_1Sledgehamr.html">Sledgehamr</a> *&#160;</td>
          <td class="paramname"><em>owner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initalize all needed structures. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>Pointer to simulation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aefb58fcf06a2c658aec35d9b175440d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb58fcf06a2c658aec35d9b175440d1">&#9670;&nbsp;</a></span>AddAllBoxes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::AddAllBoxes </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; amrex::BoxArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>box_arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all boxes on all levels to the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box_arrays</td><td>Array of BoxArray's to be added to each level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7abc012848cab999afceb48d34ba637f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abc012848cab999afceb48d34ba637f">&#9670;&nbsp;</a></span>AddBoxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::AddBoxes </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amrex::BoxArray &amp;&#160;</td>
          <td class="paramname"><em>ba</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly add boxes to a given level and fill it with data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Current level. </td></tr>
    <tr><td class="paramname">ba</td><td>BoxArray to be added to level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ab0a5321f0b195e2b151783bcde5fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab0a5321f0b195e2b151783bcde5fa7">&#9670;&nbsp;</a></span>AddToLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::AddToLayout </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a particular box to the layout structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Corresponding level. </td></tr>
    <tr><td class="paramname">thread</td><td>Local OpenMP thread id. </td></tr>
    <tr><td class="paramname">i</td><td>i-th box index. </td></tr>
    <tr><td class="paramname">j</td><td>j-th box index. </td></tr>
    <tr><td class="paramname">k</td><td>k-th box index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4458da4a915248888078544b767c6b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4458da4a915248888078544b767c6b24">&#9670;&nbsp;</a></span>AttemptRegrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sledgehamr::LocalRegrid::AttemptRegrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a local regrid on level lev after checking various criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Coarsest level for tagging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we regridded or not. </dd></dl>

</div>
</div>
<a id="a7904cbeebaf630718c2fd6c358b0ffab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7904cbeebaf630718c2fd6c358b0ffab">&#9670;&nbsp;</a></span>CheckBorders()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::CheckBorders </td>
          <td>(</td>
          <td class="paramtype">const amrex::IntVect &amp;&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const amrex::IntVect &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const amrex::IntVect &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ibff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>bff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::multi_array&lt; bool, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsledgehamr_1_1Location.html">Location</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>omp_thread_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a location we measure the distance to all adjacent coarse/fine boundaries. We add to our layout structure if the location is too close. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ci</td><td>Index to be checked. </td></tr>
    <tr><td class="paramname">c0</td><td>Lower box index of current box. </td></tr>
    <tr><td class="paramname">c1</td><td>Upper box index of current box. </td></tr>
    <tr><td class="paramname">ibff</td><td>Fine coarse level blocking factor of type int. </td></tr>
    <tr><td class="paramname">bff</td><td>Fine coarse level blocking factor but cast to double. </td></tr>
    <tr><td class="paramname">remaining</td><td>Number of adjecent coarse/fine boundaries that could still be pushed further. </td></tr>
    <tr><td class="paramname">lev</td><td>Current coarse level. </td></tr>
    <tr><td class="paramname">border</td><td>Map that indicates locations of coarse/fine boundaries. </td></tr>
    <tr><td class="paramname">closest_locations</td><td>Array containing the locations closest to a coarse/fine boundary on each OpenMP rank. <br  />
 </td></tr>
    <tr><td class="paramname">threshold</td><td>Distance threshold beyond which we don't really care about the exact distance anymore. </td></tr>
    <tr><td class="paramname">omp_thread_num</td><td>Current OpenMP thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f0308e5b708bddbedfabc7d5462507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0308e5b708bddbedfabc7d5462507b">&#9670;&nbsp;</a></span>CheckForVeto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sledgehamr::LocalRegrid::CheckForVeto </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; amrex::BoxArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>box_arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indentifies whether any part of the code wants to veto the local regrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Level to check for vetos. </td></tr>
    <tr><td class="paramname">box_arrays</td><td>Array of BoxArray's containing the local additions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we found a veto anywhere. </dd></dl>

</div>
</div>
<a id="a3a0ce70c479608f2786a4706a1e28174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0ce70c479608f2786a4706a1e28174">&#9670;&nbsp;</a></span>CheckThresholds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sledgehamr::LocalRegrid::CheckThresholds </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amrex::BoxArray &amp;&#160;</td>
          <td class="paramname"><em>ba</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks all thresholds and determines whether we should continue with the local regrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Level to be checked. </td></tr>
    <tr><td class="paramname">ba</td><td>BoxArray to be added to the given level. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we should veto the local regrid. </dd></dl>

</div>
</div>
<a id="ad1d361cc8d3d5cdf88a3b2af70b98235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d361cc8d3d5cdf88a3b2af70b98235">&#9670;&nbsp;</a></span>ClearLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::ClearLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cleans up all layout structures after the local regrid. </p>

</div>
</div>
<a id="a5a4c4e0124cce6e52a2d31d422cd1867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a4c4e0124cce6e52a2d31d422cd1867">&#9670;&nbsp;</a></span>ComputeLatestPossibleRegridTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::ComputeLatestPossibleRegridTime </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the most pessimistiv time by which we should have performed any regrid or otherwise we run risk of having features propagate outside a refined region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>Level to be used for computation. </td></tr>
    <tr><td class="paramname">lev</td><td>Coarsest level on which we tagged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa044dbf92775ab6f8ad67ddca9be6765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa044dbf92775ab6f8ad67ddca9be6765">&#9670;&nbsp;</a></span>CreateCommMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::CreateCommMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a N x N communication matrix M_{ij} between N MPI ranks. The i-th MPI rank talks to the M_{ij}-th MPI rank during the j-th communication cycle. Each rank talks to each other rank exactly once. </p>

</div>
</div>
<a id="a69abb9abd18afb23af2854dab85b325e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69abb9abd18afb23af2854dab85b325e">&#9670;&nbsp;</a></span>DealWithVeto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsledgehamr_1_1LocalRegrid.html#a5e77b4e9b1abddac86fca72caf4c6f7b">LocalRegrid::VetoResult</a> sledgehamr::LocalRegrid::DealWithVeto </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the best course of action in case the local regrid was vetoed. This could be either to do nothing, do a global regrid, or or to do a local regrid anyway followed by a global regrid at the next opportunity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Coarsest level for tagging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Suggested course of action (no/local/global regrid). </dd></dl>

</div>
</div>
<a id="aa728f1d2fe1519e19006258a6f3dd2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa728f1d2fe1519e19006258a6f3dd2af">&#9670;&nbsp;</a></span>DetermineAllBoxArrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::DetermineAllBoxArrays </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines new layout on all levels based on taggin criteria. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Coarsest level for tagging. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab78dd484cbf81ffacfc4a8901a3248ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78dd484cbf81ffacfc4a8901a3248ec">&#9670;&nbsp;</a></span>DetermineNewBoxArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double sledgehamr::LocalRegrid::DetermineNewBoxArray </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tags cells on a level and measure distance to coarse/fine boundary. If the tagged cell is too close we expand our layout structure at that location. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Level on which to tag. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Globally shortest distance between a tagged cell and coarse/fine boundary. Will be -1 if nothing has been tagged or distance is too large to reliably determine distance (&gt; blocking_factor). </dd></dl>

</div>
</div>
<a id="ad8209f8ed254d084ef0c85d17334a84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8209f8ed254d084ef0c85d17334a84b">&#9670;&nbsp;</a></span>DidGlobalRegrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::DidGlobalRegrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To be called if a global regrid on level lev has been performed. Needed in case this <a class="el" href="classsledgehamr_1_1LocalRegrid.html" title="Class to perform a local regrid (if possible).">LocalRegrid</a> module invoked the global regrid such that we can reset the relevant flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Coarsest level on which we tagged for the global regrid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbdf638db8837580b881637a3b5871d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbdf638db8837580b881637a3b5871d4">&#9670;&nbsp;</a></span>DoAttemptRegrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sledgehamr::LocalRegrid::DoAttemptRegrid </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts a local regrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Coarsest level for tagging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the local regrid was succesfull. A local regrid is considered successfull even if it has not been performed but no further action has been deemed necessary. </dd></dl>

</div>
</div>
<a id="a54eaba36170ad1032ffa996aa1823ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54eaba36170ad1032ffa996aa1823ef0">&#9670;&nbsp;</a></span>FinalizeLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::FinalizeLayout </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronizes all layout structures across OpenMP threads and MPI ranks for a particular level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Corresponding level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34e74dd5fc82512098f9516ab1660221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e74dd5fc82512098f9516ab1660221">&#9670;&nbsp;</a></span>FixAllNesting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::FixAllNesting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensures that all levels are properly nested within the lower levels. </p>

</div>
</div>
<a id="aa3c39f4e8b15c13b471f68e36a9dc33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c39f4e8b15c13b471f68e36a9dc33f">&#9670;&nbsp;</a></span>FixNesting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::FixNesting </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Will expand lower level locally to ensure the fine level is nested properly within. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Fine level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e4dfcab9bf143c7d284387c643c66fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4dfcab9bf143c7d284387c643c66fe">&#9670;&nbsp;</a></span>GetBoxCoarseFineBorders()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sledgehamr::LocalRegrid::GetBoxCoarseFineBorders </td>
          <td>(</td>
          <td class="paramtype">const amrex::Box &amp;&#160;</td>
          <td class="paramname"><em>tilebox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const amrex::IntVect &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const amrex::IntVect &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::multi_array&lt; bool, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>border</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether a box has neighbouring coarse/fine boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tilebox</td><td>Current box to check. </td></tr>
    <tr><td class="paramname">c0</td><td>Tilebox lower box index. </td></tr>
    <tr><td class="paramname">c1</td><td>Tilebox upper box index. </td></tr>
    <tr><td class="paramname">lev</td><td>Current level. </td></tr>
    <tr><td class="paramname">border</td><td>Boolean map indicating whether a coarse/fine boundary is present. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of neighbouring coarse fine boundaries. </dd></dl>

</div>
</div>
<a id="aca8f2a065d1f69ad66d46eef5f01d910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8f2a065d1f69ad66d46eef5f01d910">&#9670;&nbsp;</a></span>InitializeLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::InitializeLayout </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>max_lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates all layout structures needed for the local regrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_lev</td><td>Up to what level we need the layout structures [deprecated]. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd2eaafd8b0ef4d31171234e56bbbc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2eaafd8b0ef4d31171234e56bbbc62">&#9670;&nbsp;</a></span>InitializeLocalRegrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::InitializeLocalRegrid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up everything needed prior to a local regrid. </p>

</div>
</div>
<a id="a5c5a104f1c94bd81627803b13225c32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5a104f1c94bd81627803b13225c32e">&#9670;&nbsp;</a></span>JoinAllBoxArrays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::JoinAllBoxArrays </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; amrex::BoxArray &gt; &amp;&#160;</td>
          <td class="paramname"><em>box_arrays</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines all BoxArray's on each level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box_arrays</td><td>Array of BoxArray's for each level. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8054c3efb82b28b33e3357bda47f3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8054c3efb82b28b33e3357bda47f3ee">&#9670;&nbsp;</a></span>JoinBoxArrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::JoinBoxArrays </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">amrex::BoxArray &amp;&#160;</td>
          <td class="paramname"><em>ba</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Joins BoxArray's from multiple nodes. Simplifies box lists only locally for efficiency. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Corresponding level. </td></tr>
    <tr><td class="paramname">ba</td><td>Local BoxArray to be merged globally. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fdb62c58cea11f1be4fd4db3d827509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdb62c58cea11f1be4fd4db3d827509">&#9670;&nbsp;</a></span>ParseInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::ParseInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses all input parameters related to a local regrid. </p>

</div>
</div>
<a id="a3bfc34e198cf1d9091ae557b508c3b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bfc34e198cf1d9091ae557b508c3b83">&#9670;&nbsp;</a></span>Prechecks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sledgehamr::LocalRegrid::Prechecks </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks pre-conditions whether we even need to attempt a local regrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Coarsest level for tagging. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether we want to attempt a local regrid. </dd></dl>

</div>
</div>
<a id="a8acdc638840f81d22adff7ad9bd1f4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8acdc638840f81d22adff7ad9bd1f4cf">&#9670;&nbsp;</a></span>TagAndMeasure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::TagAndMeasure </td>
          <td>(</td>
          <td class="paramtype">const amrex::Dim3 &amp;&#160;</td>
          <td class="paramname"><em>lo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const amrex::Dim3 &amp;&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>remaining</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const amrex::Array4&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>tag_arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const amrex::IntVect &amp;&#160;</td>
          <td class="paramname"><em>c0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const amrex::IntVect &amp;&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ibff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>bff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::multi_array&lt; bool, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classsledgehamr_1_1Location.html">Location</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>closest_locations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>omp_thread_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds tagged cells within a box and measures its distance of any coarse/fine boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lo</td><td>Lower coordinate of current box. </td></tr>
    <tr><td class="paramname">hi</td><td>Higher coordinate of current box. </td></tr>
    <tr><td class="paramname">remaining</td><td>Number of adjecent coarse/fine boundaries that could still be pushed further. </td></tr>
    <tr><td class="paramname">tag_arr</td><td>TagArray containing all tags. </td></tr>
    <tr><td class="paramname">c0</td><td>Lower box index of current box. </td></tr>
    <tr><td class="paramname">c1</td><td>Upper box index of current box. </td></tr>
    <tr><td class="paramname">lev</td><td>Current coarse level. </td></tr>
    <tr><td class="paramname">ibff</td><td>Fine coarse level blocking factor of type int. </td></tr>
    <tr><td class="paramname">bff</td><td>Fine coarse level blocking factor but cast to double. </td></tr>
    <tr><td class="paramname">border</td><td>Map that indicates locations of coarse/fine boundaries. </td></tr>
    <tr><td class="paramname">closest_locations</td><td>Array containing the locations closest to a coarse/fine boundary on each OpenMP rank. <br  />
 </td></tr>
    <tr><td class="paramname">threshold</td><td>Distance threshold beyond which we don't really care about the exact distance anymore. </td></tr>
    <tr><td class="paramname">omp_thread_num</td><td>Current OpenMP thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91da1033161cc643d7e352c845a81b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91da1033161cc643d7e352c845a81b85">&#9670;&nbsp;</a></span>WrapBoxArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">amrex::BoxArray sledgehamr::LocalRegrid::WrapBoxArray </td>
          <td>(</td>
          <td class="paramtype">amrex::BoxArray &amp;&#160;</td>
          <td class="paramname"><em>ba</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps a box array accross periodic boundary conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ba</td><td>BoxArray. </td></tr>
    <tr><td class="paramname">N</td><td>Total number of potential boxes along an axis. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf96edb1e54961ac32416d58020bd1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf96edb1e54961ac32416d58020bd1d2">&#9670;&nbsp;</a></span>WrapIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sledgehamr::LocalRegrid::WrapIndices </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>lev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps box indicies across the periodic boundary conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lev</td><td>Level on which to perform wrapping. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8d0f98de185f108dae15af7e2997d886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d0f98de185f108dae15af7e2997d886">&#9670;&nbsp;</a></span>comm_matrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;int&gt; &gt; sledgehamr::LocalRegrid::comm_matrix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MPI communication matrix. Look-up table used by the <a class="el" href="classsledgehamr_1_1UniqueLayout.html" title="This class ensures the uniqueness of a grid by reducing the problem to sets of touples....">UniqueLayout</a> class. </p>

</div>
</div>
<a id="a4e903f8bbe42b29f94666c569e734bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e903f8bbe42b29f94666c569e734bee">&#9670;&nbsp;</a></span>do_global_regrid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; sledgehamr::LocalRegrid::do_global_regrid</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag that will be checked the <a class="el" href="classsledgehamr_1_1TimeStepper.html" title="Class that takes care of the sub-cycling in time algorithm and schedules regrids when necessary.">TimeStepper</a> module to force a global regrid. </p>

</div>
</div>
<a id="a22ed6ede76749d7a30af53b4e996679b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ed6ede76749d7a30af53b4e996679b">&#9670;&nbsp;</a></span>force_global_regrid_at_restart</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sledgehamr::LocalRegrid::force_global_regrid_at_restart = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If flag set to true we will skip the local regrid once. </p>

</div>
</div>
<a id="aa13a330b0df260418a96b950fb3446bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13a330b0df260418a96b950fb3446bc">&#9670;&nbsp;</a></span>last_numPts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;long long&gt; sledgehamr::LocalRegrid::last_numPts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of cells contained in each level after the last global regrid. </p>

</div>
</div>
<a id="a7c65ca82aff444f6e0ec107f092d970e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c65ca82aff444f6e0ec107f092d970e">&#9670;&nbsp;</a></span>latest_possible_regrid_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; sledgehamr::LocalRegrid::latest_possible_regrid_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contains the time by which we should have done a regrid. </p>

</div>
</div>
<a id="a48b38ea21c94615db481b11a56fadd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b38ea21c94615db481b11a56fadd9f">&#9670;&nbsp;</a></span>layouts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; std::unique_ptr&lt;<a class="el" href="classsledgehamr_1_1UniqueLayout.html">UniqueLayout</a>&gt; &gt; &gt; sledgehamr::LocalRegrid::layouts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of UniqueLayouts for each level and each core. </p>

</div>
</div>
<a id="a713ec6e07916351b8b41ecab3f2e2a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713ec6e07916351b8b41ecab3f2e2a17">&#9670;&nbsp;</a></span>max_local_regrids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sledgehamr::LocalRegrid::max_local_regrids = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How often we are allowed to do a local regrid in a row. </p>

</div>
</div>
<a id="a7979ef82194a55c08f939f5cfd33d943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7979ef82194a55c08f939f5cfd33d943">&#9670;&nbsp;</a></span>min_distance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; sledgehamr::LocalRegrid::min_distance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum distance of a tagged cell to a coarse/fine boundary for each OpenMP thread. </p>

</div>
</div>
<a id="a8403a32f1028bda506f2e2f4ea7e7eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8403a32f1028bda506f2e2f4ea7e7eef">&#9670;&nbsp;</a></span>n_error_buf</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sledgehamr::LocalRegrid::n_error_buf = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size of error buffer. </p>

</div>
</div>
<a id="abb324e0d3669efb0a2337b69892ef957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb324e0d3669efb0a2337b69892ef957">&#9670;&nbsp;</a></span>no_local_regrid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; sledgehamr::LocalRegrid::no_local_regrid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we want to skip the local regrid entirely at a given level. </p>

</div>
</div>
<a id="a042da77091f22870797a9d406fa12506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042da77091f22870797a9d406fa12506">&#9670;&nbsp;</a></span>nregrids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sledgehamr::LocalRegrid::nregrids = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counts number of consecutive local regrids. </p>

</div>
</div>
<a id="a4d60672b3f1690a0b299a97b36358648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d60672b3f1690a0b299a97b36358648">&#9670;&nbsp;</a></span>sim</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsledgehamr_1_1Sledgehamr.html">Sledgehamr</a>* sledgehamr::LocalRegrid::sim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the simulation. </p>

</div>
</div>
<a id="a5e86a8af0dd02440edea03389daeb1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e86a8af0dd02440edea03389daeb1d3">&#9670;&nbsp;</a></span>veto_level</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sledgehamr::LocalRegrid::veto_level = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lowest level that would rather do a global regrid than a local. </p>

</div>
</div>
<a id="a3d091ebbe33a613e98ac5e0a6584f7d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d091ebbe33a613e98ac5e0a6584f7d9">&#9670;&nbsp;</a></span>volume_threshold_accumulated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double sledgehamr::LocalRegrid::volume_threshold_accumulated = 1.1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strong threshold that decide whether we want to do a local or global regrid. </p>

</div>
</div>
<a id="ae7e235329d39882b756791f9e94e609d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e235329d39882b756791f9e94e609d">&#9670;&nbsp;</a></span>volume_threshold_single</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double sledgehamr::LocalRegrid::volume_threshold_single = 1.05</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weak threshold that decide whether we want to do a local or global regrid. </p>

</div>
</div>
<a id="ab5c0c64729d05d204f461d223d01bc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c0c64729d05d204f461d223d01bc72">&#9670;&nbsp;</a></span>wrapped_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;int&gt; &gt; sledgehamr::LocalRegrid::wrapped_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look-up table of wrapped indices for periodic boundary conditions. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>source/local_regrid/<a class="el" href="local__regrid_8h_source.html">local_regrid.h</a></li>
<li>source/local_regrid/<a class="el" href="local__regrid_8cpp.html">local_regrid.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
