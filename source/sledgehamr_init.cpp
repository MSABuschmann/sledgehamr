#include <iostream>

#include <AMReX.H>
#include <AMReX_ParmParse.H>
#include <AMReX_Print.H>

#include "projects.h"
#include "sledgehamr_init.h"

namespace sledgehamr {

/** @brief General initialization needed before sledgehamr itself can be
 *         initialized.
 */
SledgehamrInit::SledgehamrInit() {
    DetermineProjectName();
    FinishAMReXSetup();
}

/** @brief Will return a pointer to a Sledgehamr instance depending on which
 *         project has been selected. This class will remain owner of instance
 *         but given the singleton nature of everything we just ignore this.
 *         We do an implicit cast here from derived to base.
 * return   Sledgehamr instance. NULL if no corresponding project has been
 *          found.
 */
Sledgehamr *SledgehamrInit::CreateInstance() {
    // Call macro generated by 'make'. Will create and return new instance of
    // derived project class corresponding to the requested project name. Will
    // do nothing if no matching project class found. Implicit cast to base upon
    // return.
    SLEDGEHAMR_PROJECT(project_name);
    amrex::Print() << "Project not found!" << std::endl;
    return NULL;
}

/** @brief Sets project name using the inputs file.
 */
void SledgehamrInit::DetermineProjectName() {
    amrex::ParmParse pp("project");
    pp.get("name", project_name);
}

/** @brief Overrides and/or sets parameters to force correct behaviour of
 *         amrex::AmrCore.
 */
void SledgehamrInit::FinishAMReXSetup() {
    // Determine requested grid size.
    amrex::ParmParse pp_amr("amr");
    int grid_size = 0;
    pp_amr.get("coarse_level_grid_size", grid_size);
    std::vector<int> grid_vect(3, grid_size);
    pp_amr.addarr("n_cell", grid_vect);
    pp_amr.add("max_grid_size", grid_size);

    // Determine maximum number of levels.
    int max_refinement_levels = 0;
    pp_amr.get("max_refinement_levels", max_refinement_levels);
    pp_amr.add("max_level", max_refinement_levels);

    // Set box dimensions.
    amrex::ParmParse pp_sim("sim");
    double L;
    pp_sim.get("L", L);

    std::vector<double> prob_lo(3, 0);
    std::vector<double> prob_hi(3, L);
    std::vector<int> periodic(3, 1);

    amrex::ParmParse pp_geo("geometry");
    pp_geo.addarr("prob_lo", prob_lo);
    pp_geo.addarr("prob_hi", prob_hi);
    pp_geo.addarr("is_periodic", periodic);

    // Set Integrator type.
    amrex::ParmParse pp_inte("integrator");
    int inte_type;
    pp_inte.get("type", inte_type);

    amrex::ParmParse pp_intn("integration");
    if (inte_type >= 0 && inte_type <= 4) {
        pp_intn.add("type", 1);
        pp_intn.add("rk.type", inte_type);
    }
}

}; // namespace sledgehamr
